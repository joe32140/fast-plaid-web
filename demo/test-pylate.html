<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Test pylate-rs Integration</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .log { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 4px; }
        .error { background: #ffebee; color: #c62828; }
        .success { background: #e8f5e8; color: #2e7d32; }
        button { padding: 10px 20px; margin: 5px; }
    </style>
</head>
<body>
    <h1>pylate-rs Integration Test</h1>
    
    <button onclick="testPylateImport()">1. Test pylate-rs Import</button>
    <button onclick="testModelLoading()">2. Test Model Loading</button>
    <button onclick="testQueryEncoding()">3. Test Query Encoding</button>
    <button onclick="testDocumentEncoding()">4. Test Document Encoding</button>
    
    <div id="logs"></div>

    <script type="module">
        let ColBERT = null;
        let model = null;
        
        function log(message, type = 'log') {
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            document.getElementById('logs').appendChild(div);
            console.log(message);
        }
        
        window.testPylateImport = async function() {
            try {
                log('üöÄ Testing pylate-rs import...');
                
                const pylateModule = await import('./node_modules/pylate-rs/pylate_rs.js');
                log('‚úÖ pylate-rs module imported');
                
                await pylateModule.default();
                log('‚úÖ WASM initialized');
                
                ColBERT = pylateModule.ColBERT;
                log(`‚úÖ ColBERT class available: ${typeof ColBERT}`);
                
                log('üéâ pylate-rs import test successful!', 'success');
                
            } catch (error) {
                log(`‚ùå pylate-rs import failed: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.testModelLoading = async function() {
            if (!ColBERT) {
                log('‚ùå ColBERT not available. Run import test first.', 'error');
                return;
            }
            
            try {
                log('üì• Testing model loading with lightonai/answerai-colbert-small-v1...');
                
                const modelRepo = 'lightonai/answerai-colbert-small-v1';
                const requiredFiles = [
                    'tokenizer.json',
                    'model.safetensors',
                    'config.json',
                    'config_sentence_transformers.json',
                    '1_Dense/model.safetensors',
                    '1_Dense/config.json',
                    'special_tokens_map.json',
                ];
                
                log(`üîç Fetching ${requiredFiles.length} files...`);
                
                const responses = await Promise.all(
                    requiredFiles.map(file => 
                        fetch(`https://huggingface.co/${modelRepo}/resolve/main/${file}`)
                    )
                );
                
                // Check responses
                for (let i = 0; i < responses.length; i++) {
                    const response = responses[i];
                    const file = requiredFiles[i];
                    if (!response.ok) {
                        throw new Error(`Failed to fetch ${file}: ${response.status}`);
                    }
                    log(`‚úÖ Fetched ${file} (${response.headers.get('content-length')} bytes)`);
                }
                
                log('üîß Converting to Uint8Arrays...');
                const modelFiles = await Promise.all(
                    responses.map(res => res.arrayBuffer().then(b => new Uint8Array(b)))
                );
                
                log('üèóÔ∏è Initializing ColBERT model...');
                const [tokenizer, modelData, config, stConfig, dense, denseConfig, tokensConfig] = modelFiles;
                
                model = new ColBERT(
                    modelData,
                    dense,
                    tokenizer,
                    config,
                    stConfig,
                    denseConfig,
                    tokensConfig,
                    32
                );
                
                log('üéâ Model loading test successful!', 'success');
                
            } catch (error) {
                log(`‚ùå Model loading failed: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.testQueryEncoding = async function() {
            if (!model) {
                log('‚ùå Model not loaded. Run model loading test first.', 'error');
                return;
            }
            
            try {
                log('üî§ Testing query encoding...');
                
                const testQuery = "What is machine learning?";
                log(`üìù Encoding query: "${testQuery}"`);
                
                // Use the correct API format based on working reference code
                const result = await model.encode({
                    sentences: [testQuery],
                    is_query: true
                });
                
                log('üîç Raw result:', result);
                
                // Handle ColBERT result format (based on working code)
                let embeddings;
                if (Array.isArray(result)) {
                    embeddings = result;
                } else if (result && result.embeddings && Array.isArray(result.embeddings)) {
                    embeddings = result.embeddings[0]; // Unwrap first sentence
                } else if (result && result.data && Array.isArray(result.data)) {
                    embeddings = result.data[0];
                } else if (result && Array.isArray(result[0])) {
                    embeddings = result[0];
                } else {
                    throw new Error('Unknown ColBERT result format');
                }
                
                log(`‚úÖ Query encoding successful!`);
                log(`üîç Embeddings type: ${typeof embeddings}`);
                log(`üîç Embeddings structure:`, embeddings);
                log(`üîç Embeddings keys: ${Object.keys(embeddings)}`);
                log(`üîç Embeddings length property: ${embeddings.length}`);
                if (embeddings.data) log(`üîç Embeddings.data:`, embeddings.data);
                if (embeddings[0]) log(`üîç Embeddings[0]:`, embeddings[0]);
                
                // Validate embeddings structure
                if (!Array.isArray(embeddings) || embeddings.length === 0) {
                    throw new Error('ColBERT returned empty or invalid embeddings');
                }
                
                log(`üìä Generated ${embeddings.length} token vectors`);
                log(`üîç First token vector length: ${embeddings[0]?.length}`);
                
                // Show sample values from first token vector
                if (embeddings[0] && Array.isArray(embeddings[0]) && embeddings[0].length > 0) {
                    const firstTokenVec = embeddings[0];
                    const sampleValues = firstTokenVec.slice(0, 5).map(x => {
                        if (typeof x === 'number') {
                            return x.toFixed(4);
                        } else {
                            return String(x);
                        }
                    });
                    log(`üìä First token vector sample: [${sampleValues.join(', ')}...]`);
                } else {
                    log(`‚ö†Ô∏è Unexpected token vector structure`);
                }
                
                log('üéâ Query encoding test successful!', 'success');
                
            } catch (error) {
                log(`‚ùå Query encoding failed: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.testDocumentEncoding = async function() {
            if (!model) {
                log('‚ùå Model not loaded. Run model loading test first.', 'error');
                return;
            }
            
            try {
                log('üìÑ Testing document encoding...');
                
                const testDoc = "Machine learning is a subset of artificial intelligence that enables computers to learn from data.";
                log(`üìù Encoding document: "${testDoc.substring(0, 50)}..."`);
                
                // Use the correct API format based on working reference code
                const result = await model.encode({
                    sentences: [testDoc],
                    is_query: false
                });
                
                log('üîç Raw result:', result);
                
                // Handle ColBERT result format (based on working code)
                let embeddings;
                if (Array.isArray(result)) {
                    embeddings = result;
                } else if (result && result.embeddings && Array.isArray(result.embeddings)) {
                    embeddings = result.embeddings[0]; // Unwrap first sentence
                } else if (result && result.data && Array.isArray(result.data)) {
                    embeddings = result.data[0];
                } else if (result && Array.isArray(result[0])) {
                    embeddings = result[0];
                } else {
                    throw new Error('Unknown ColBERT result format');
                }
                
                log(`‚úÖ Document encoding successful!`);
                log(`üîç Embeddings type: ${typeof embeddings}`);
                log(`üîç Embeddings structure:`, embeddings);
                
                // Validate embeddings structure
                if (!Array.isArray(embeddings) || embeddings.length === 0) {
                    throw new Error('ColBERT returned empty or invalid embeddings');
                }
                
                log(`üìä Generated ${embeddings.length} token vectors`);
                log(`üîç First token vector length: ${embeddings[0]?.length}`);
                
                // Show sample values from first token vector
                if (embeddings[0] && Array.isArray(embeddings[0]) && embeddings[0].length > 0) {
                    const firstTokenVec = embeddings[0];
                    const sampleValues = firstTokenVec.slice(0, 5).map(x => {
                        if (typeof x === 'number') {
                            return x.toFixed(4);
                        } else {
                            return String(x);
                        }
                    });
                    log(`üìä First token vector sample: [${sampleValues.join(', ')}...]`);
                } else {
                    log(`‚ö†Ô∏è Unexpected token vector structure`);
                }
                
                log('üéâ Document encoding test successful!', 'success');
                
            } catch (error) {
                log(`‚ùå Document encoding failed: ${error.message}`, 'error');
                console.error(error);
            }
        };
    </script>
</body>
</html>