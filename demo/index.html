<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastPlaid Demo - ColBERT Search with 4-bit Quantization (1000 Papers)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 36px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 18px;
            opacity: 0.9;
        }

        .stats-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card.green {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .stat-card.orange {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .search-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .search-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #queryInput {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        #queryInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .comparison-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .method-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .method-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .method-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .method-time {
            font-size: 18px;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 20px;
            background: #f0f0f0;
        }

        .method-time.fast {
            background: #d4edda;
            color: #155724;
        }

        .method-time.slow {
            background: #f8d7da;
            color: #721c24;
        }

        .method-description {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .result-item {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
        }

        .result-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .result-score {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .result-abstract {
            font-size: 14px;
            color: #777;
            line-height: 1.4;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .comparison-panel {
                grid-template-columns: 1fr;
            }

            .search-controls {
                flex-direction: column;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üÜö Direct MaxSim vs FastPlaid</h1>
            <p>Search 1000 arXiv Papers: Float32 vs 4-bit Quantized ColBERT</p>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <h2 style="margin-bottom: 15px;">üìä Index Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="numPapers">-</div>
                    <div class="stat-label">Research Papers</div>
                </div>
                <div class="stat-card orange">
                    <div class="stat-value" id="directSize">-</div>
                    <div class="stat-label">Direct MaxSim (float32)</div>
                </div>
                <div class="stat-card green">
                    <div class="stat-value" id="fastplaidSize">-</div>
                    <div class="stat-label">FastPlaid (4-bit)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="compression">-</div>
                    <div class="stat-label">Size Reduction</div>
                </div>
            </div>
            <div id="statusMessage" style="margin-top: 20px;"></div>
        </div>

        <!-- Search Panel -->
        <div class="search-panel">
            <h2 style="margin-bottom: 15px;">üîç Search Research Papers</h2>
            <div class="search-controls">
                <input type="text" id="queryInput" placeholder="Enter your search query (e.g., 'machine learning for NLP')" />
                <button class="btn btn-primary" id="searchBtn">Search Both</button>
            </div>
        </div>

        <!-- Comparison Panel -->
        <div class="comparison-panel" id="comparisonPanel" style="display: none;">
            <!-- Direct MaxSim Results -->
            <div class="method-panel">
                <div class="method-header">
                    <div class="method-title">üê¢ Direct MaxSim</div>
                    <div class="method-time" id="directTime">- ms</div>
                </div>
                <div class="method-description">
                    <strong>Float32 embeddings</strong><br>
                    Full precision, searches all 1000 papers
                </div>
                <div id="directResults"></div>
            </div>

            <!-- FastPlaid Results -->
            <div class="method-panel">
                <div class="method-header">
                    <div class="method-title">‚ö° FastPlaid</div>
                    <div class="method-time" id="fastplaidTime">- ms</div>
                </div>
                <div class="method-description">
                    <strong>4-bit quantized + IVF</strong> (Rust WASM)<br>
                    8x smaller, <span id="clustersProbed">~6</span> clusters ‚Üí <span id="candidatesCount">~300</span> candidates
                </div>
                <div id="fastplaidResults"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { FastPlaidQuantized } from './pkg/fast_plaid_rust.js';
        import { PrecomputedIndexLoader } from './precomputed-index-loader.js';

        let indexLoader = null;
        let directEmbeddings = null;
        let fastPlaidWasm = null;  // WASM instance
        let papers = null;
        let colbertModel = null;

        // Expose to window for console access (to save index)
        window.fastPlaidWasm = null;
        window.saveFastPlaidIndex = () => {
            if (!window.fastPlaidWasm) {
                console.error('‚ùå FastPlaid not loaded yet!');
                return;
            }
            const indexBytes = window.fastPlaidWasm.save_index();
            const blob = new Blob([indexBytes], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'index.fastplaid';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('‚úÖ Downloaded index.fastplaid! Move to demo/data/');
        };

        // Loading state management for both indexes
        const loadingState = {
            directMaxSim: { loaded: false, loading: false, error: null },
            fastPlaid: { loaded: false, loading: false, error: null },
            colbert: { loaded: false, loading: false, error: null }
        };

        // Update UI to show loading state
        function updateLoadingUI(customMessage = null) {
            const directSize = document.getElementById('directSize');
            const fastplaidSize = document.getElementById('fastplaidSize');

            // Direct MaxSim size box
            if (loadingState.directMaxSim.loading) {
                directSize.innerHTML = '<span style="font-size:20px;">‚è≥</span> Loading...';
            } else if (loadingState.directMaxSim.error) {
                directSize.innerHTML = '<span style="font-size:20px;">‚ùå</span> Error';
            } else if (loadingState.directMaxSim.loaded) {
                directSize.textContent = '49.5 MB';
            } else {
                directSize.textContent = '-';
            }

            // FastPlaid size box (with custom message support)
            if (customMessage) {
                fastplaidSize.innerHTML = `<span style="font-size:20px;">üîß</span> ${customMessage}`;
            } else if (loadingState.fastPlaid.loading) {
                fastplaidSize.innerHTML = '<span style="font-size:20px;">‚è≥</span> Loading...';
            } else if (loadingState.fastPlaid.error) {
                fastplaidSize.innerHTML = '<span style="font-size:20px;">‚ùå</span> Error';
            } else if (loadingState.fastPlaid.loaded) {
                fastplaidSize.textContent = '6.2 MB';
            } else {
                fastplaidSize.textContent = '-';
            }

            // Update compression ratio if both loaded
            if (loadingState.directMaxSim.loaded && loadingState.fastPlaid.loaded) {
                document.getElementById('compression').textContent = '8.0x';
            } else {
                document.getElementById('compression').textContent = '-';
            }
        }

        // Helper function to retry WASM operations
        async function retryAsync(fn, maxRetries = 3, delayMs = 500) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    console.warn(`Attempt ${attempt}/${maxRetries} failed:`, error.message);

                    if (attempt === maxRetries) {
                        throw error;
                    }

                    // Exponential backoff
                    const delay = delayMs * Math.pow(2, attempt - 1);
                    console.log(`Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));

                    // Force garbage collection if possible
                    if (window.gc) {
                        window.gc();
                    }
                }
            }
        }

        // Load Direct MaxSim embeddings (async, independent)
        async function loadDirectMaxSimIndex() {
            loadingState.directMaxSim.loading = true;
            updateLoadingUI();

            try {
                console.log('üì• Loading Direct MaxSim embeddings...');
                showStatus('Loading Direct MaxSim embeddings...', 'info');

                const directData = await indexLoader.loadDirectMaxSimEmbeddings();
                directEmbeddings = directData.embeddings;

                loadingState.directMaxSim.loaded = true;
                loadingState.directMaxSim.loading = false;
                updateLoadingUI();

                console.log('‚úÖ Direct MaxSim embeddings loaded!');
                updateOverallStatus();
            } catch (error) {
                console.error('‚ùå Error loading Direct MaxSim:', error);
                loadingState.directMaxSim.error = error.message;
                loadingState.directMaxSim.loading = false;
                updateLoadingUI();
                updateOverallStatus();
            }
        }

        // Load FastPlaid index (async, independent)
        async function loadFastPlaidIndex() {
            loadingState.fastPlaid.loading = true;
            updateLoadingUI();

            try {
                console.log('üì• Loading FastPlaid index...');

                // Initialize WASM if not already done
                await retryAsync(async () => {
                    await init();
                    console.log('‚úÖ WASM initialized');
                }, 3, 500);

                // Try to load precomputed .fastplaid index first (FAST!)
                try {
                    console.log('üîç Checking for precomputed index.fastplaid...');
                    const indexResponse = await fetch('./data/index.fastplaid');

                    if (indexResponse.ok) {
                        console.log('üì¶ Loading precomputed .fastplaid index from disk...');
                        showStatus('üíæ Loading FastPlaid from precomputed index...', 'info');
                        updateLoadingUI('Loading...');

                        const startTime = performance.now();
                        const indexBytes = await indexResponse.arrayBuffer();

                        fastPlaidWasm = new FastPlaidQuantized();
                        window.fastPlaidWasm = fastPlaidWasm;  // Expose to console
                        fastPlaidWasm.load_index(new Uint8Array(indexBytes));

                        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
                        console.log(`‚úÖ FastPlaid loaded from disk in ${loadTime}s!`);

                        loadingState.fastPlaid.loaded = true;
                        loadingState.fastPlaid.loading = false;
                        updateLoadingUI();
                        updateOverallStatus();
                        return; // Success - exit early!
                    }
                } catch (e) {
                    console.log('‚ö†Ô∏è Precomputed index not found, will build from embeddings');
                }

                // Fallback: Build from embeddings (SLOW but works)
                console.log('üî® Building FastPlaid index from embeddings...');

                // Wait for Direct MaxSim to load first (we need the embeddings)
                console.log('‚è≥ Waiting for Direct MaxSim embeddings to load...');
                showStatus('‚è≥ Waiting for embeddings to load...', 'info');

                while (!loadingState.directMaxSim.loaded && !loadingState.directMaxSim.error) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (loadingState.directMaxSim.error) {
                    throw new Error('Cannot build FastPlaid: Direct MaxSim embeddings failed to load');
                }

                console.log('‚úÖ Embeddings ready, now quantizing to 4-bit + building IVF index...');
                showStatus('üîß Quantizing to 4-bit + building IVF clusters in WASM (10-15s)...', 'info');
                updateLoadingUI('Building...');

                // Create WASM instance and build quantized index
                const startTime = performance.now();
                await retryAsync(async () => {
                    fastPlaidWasm = new FastPlaidQuantized();
                    window.fastPlaidWasm = fastPlaidWasm;  // Expose to console

                    // Prepare embeddings and doc_info for WASM
                    const flatEmbeddings = new Float32Array(
                        directEmbeddings.flatMap(doc => Array.from(doc.embedding))
                    );
                    const docInfo = new BigInt64Array(
                        directEmbeddings.flatMap((doc, idx) => [BigInt(idx), BigInt(doc.numTokens)])
                    );

                    // Let WASM quantize (256 centroids) and build IVF index
                    await fastPlaidWasm.load_documents_quantized(flatEmbeddings, docInfo, 256);
                }, 3, 1000);

                const buildTime = ((performance.now() - startTime) / 1000).toFixed(1);
                console.log(`‚úÖ FastPlaid index built in ${buildTime}s (4-bit quantization + IVF clustering)`);

                // Optionally save the built index (disabled to avoid repeated downloads)
                // To save manually: Open browser console and run:
                //   saveIndexToFile()
                window.saveIndexToFile = () => {
                    try {
                        console.log('üíæ Saving built index to fastplaid_index.bin...');
                        const indexBytes = fastPlaidWasm.save_index();
                        const blob = new Blob([indexBytes], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'fastplaid_index.bin';
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log('‚úÖ Index saved! Move it to demo/data/ to use as precomputed index.');
                    } catch (err) {
                        console.error('‚ö†Ô∏è  Failed to save index:', err);
                    }
                };
                console.log('üí° To save index: run saveIndexToFile() in console');

                loadingState.fastPlaid.loaded = true;
                loadingState.fastPlaid.loading = false;
                updateLoadingUI();

                updateOverallStatus();
            } catch (error) {
                console.error('‚ùå Error loading FastPlaid:', error);
                loadingState.fastPlaid.error = error.message;
                loadingState.fastPlaid.loading = false;
                updateLoadingUI();

                let helpText = '';
                if (error.message.includes('Table.grow') || error.message.includes('Memory')) {
                    helpText = '<br><br>üí° This is a WASM memory issue. Try:<br>' +
                               '‚Ä¢ Refreshing the page (Ctrl+Shift+R)<br>' +
                               '‚Ä¢ Closing other tabs to free memory<br>' +
                               '‚Ä¢ Using a browser with more WASM support (Chrome/Edge)';
                } else if (error.message.includes('fetch') || error.message.includes('network')) {
                    helpText = '<br><br>üí° Network issue. Make sure embeddings.bin loaded successfully.';
                }
                showStatus(`‚ùå FastPlaid Error: ${error.message}${helpText}`, 'error');
                updateOverallStatus();
            }
        }

        // Load ColBERT model for query encoding
        async function loadColBertModel() {
            loadingState.colbert.loading = true;

            try {
                console.log('ü§ñ Loading ColBERT model...');
                showStatus('Loading ColBERT model for query encoding...', 'info');

                // Load mxbai-integration.js if not already loaded
                if (!window.MxbaiEdgeColbertIntegration) {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = './mxbai-integration.js';
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }

                colbertModel = new window.MxbaiEdgeColbertIntegration();
                await colbertModel.initializeModel();

                loadingState.colbert.loaded = true;
                loadingState.colbert.loading = false;

                console.log('‚úÖ ColBERT model loaded!');
                updateOverallStatus();
            } catch (error) {
                console.error('‚ùå Error loading ColBERT:', error);
                loadingState.colbert.error = error.message;
                loadingState.colbert.loading = false;
                showStatus(`‚ùå ColBERT Error: ${error.message}`, 'error');
                updateOverallStatus();
            }
        }

        // Update overall status message
        function updateOverallStatus() {
            const direct = loadingState.directMaxSim;
            const fastplaid = loadingState.fastPlaid;
            const colbert = loadingState.colbert;

            // Count loaded, loading, errored
            const loaded = [direct.loaded, fastplaid.loaded, colbert.loaded].filter(Boolean).length;
            const loading = [direct.loading, fastplaid.loading, colbert.loading].filter(Boolean).length;
            const errors = [direct.error, fastplaid.error, colbert.error].filter(Boolean).length;

            if (loaded === 3) {
                showStatus(`‚úÖ All systems ready! Try: "transformer attention mechanisms"`, 'success');
                document.getElementById('searchBtn').disabled = false;
            } else if (errors > 0 && loading === 0) {
                let msg = '‚ö†Ô∏è Partial system ready. ';
                if (direct.loaded) msg += 'Direct MaxSim: ‚úÖ ';
                if (fastplaid.loaded) msg += 'FastPlaid: ‚úÖ ';
                if (colbert.loaded) msg += 'ColBERT: ‚úÖ';
                showStatus(msg, 'info');

                // Enable search if at least one index and colbert are ready
                if (colbert.loaded && (direct.loaded || fastplaid.loaded)) {
                    document.getElementById('searchBtn').disabled = false;
                }
            } else if (loading > 0) {
                let msg = '‚è≥ Loading... ';
                if (direct.loading) msg += 'Direct MaxSim... ';
                if (fastplaid.loading) msg += 'FastPlaid... ';
                if (colbert.loading) msg += 'ColBERT... ';
                showStatus(msg, 'info');
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            showStatus('Initializing...', 'info');
            updateLoadingUI();

            try {
                indexLoader = new PrecomputedIndexLoader('./data/fastplaid_4bit');

                // Load papers metadata first (required for display)
                console.log('üìÇ Loading papers metadata...');
                papers = await indexLoader.loadPapersMetadata();
                document.getElementById('numPapers').textContent = papers.length;
                console.log(`‚úÖ Loaded ${papers.length} papers metadata`);

                // Start loading all indexes in parallel (truly independent)
                Promise.all([
                    loadDirectMaxSimIndex(),
                    loadFastPlaidIndex(),
                    loadColBertModel()
                ]).catch(err => {
                    console.error('Unexpected error in parallel loading:', err);
                });

                // Attach event listeners
                document.getElementById('searchBtn').addEventListener('click', performSearch);
                document.getElementById('queryInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !document.getElementById('searchBtn').disabled) {
                        performSearch();
                    }
                });

            } catch (error) {
                console.error('Critical initialization error:', error);
                showStatus(`‚ùå Critical Error: ${error.message}`, 'error');
            }
        });

        // MaxSim scoring function
        function maxSim(queryTokens, docTokens, numQueryTokens, numDocTokens, embeddingDim) {
            let totalScore = 0;
            for (let q = 0; q < numQueryTokens; q++) {
                let maxScore = -Infinity;
                for (let d = 0; d < numDocTokens; d++) {
                    let dotProduct = 0;
                    for (let i = 0; i < embeddingDim; i++) {
                        dotProduct += queryTokens[q * embeddingDim + i] * docTokens[d * embeddingDim + i];
                    }
                    maxScore = Math.max(maxScore, dotProduct);
                }
                totalScore += maxScore;
            }
            return totalScore;
        }

        // Direct MaxSim search
        function searchDirectMaxSim(queryEmb, numQueryTokens, embeddingDim, topK) {
            const scores = [];

            for (let docId = 0; docId < directEmbeddings.length; docId++) {
                const docEmb = directEmbeddings[docId];
                const score = maxSim(queryEmb, docEmb.embedding, numQueryTokens, docEmb.numTokens, embeddingDim);
                scores.push({ docId, score });
            }

            // Sort by score and return top-K
            scores.sort((a, b) => b.score - a.score);
            return scores.slice(0, topK).map(s => ({
                paper: papers[s.docId],
                score: s.score
            }));
        }

        // FastPlaid search using WASM (4-bit quantized + IVF)
        function searchFastPlaid(queryEmb, numQueryTokens, embeddingDim, topK) {
            // WASM expects query_shape: [batch_size, seq_len, embedding_dim]
            const queryShape = new Uint32Array([1, numQueryTokens, embeddingDim]);

            // Use WASM's native search with IVF clustering
            const wasmResultJson = fastPlaidWasm.search(queryEmb, queryShape, topK);

            // Parse JSON result
            const wasmResults = JSON.parse(wasmResultJson);
            const firstResult = wasmResults[0]; // Get first query result (batch_size=1)

            // Log IVF statistics
            console.log(`‚ö° IVF: Probed ${firstResult.num_clusters_probed} clusters, searched ${firstResult.candidates_searched}/${papers.length} papers`);

            // Convert WASM result to our format
            return {
                results: firstResult.passage_ids.map((docId, idx) => ({
                    paper: papers[docId],
                    score: firstResult.scores[idx]
                })),
                candidatesSearched: firstResult.candidates_searched,
                numClustersProbed: firstResult.num_clusters_probed
            };
        }

        async function performSearch() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            // Check if ColBERT is ready
            if (!loadingState.colbert.loaded) {
                showStatus('‚è≥ ColBERT model is still loading, please wait...', 'info');
                return;
            }

            // Check if at least one index is ready
            if (!loadingState.directMaxSim.loaded && !loadingState.fastPlaid.loaded) {
                showStatus('‚è≥ Both indexes are still loading, please wait...', 'info');
                return;
            }

            showStatus('Encoding query...', 'info');
            document.getElementById('searchBtn').disabled = true;

            try {
                // Encode query using ColBERT
                const queryEncoded = await colbertModel.encodeText(query, true);
                const queryEmb = queryEncoded.embeddings;
                const numQueryTokens = queryEncoded.numTokens;
                const embeddingDim = queryEncoded.tokenDim;

                console.log('üîç Query:', query);
                console.log('   Tokens:', numQueryTokens, 'Dim:', embeddingDim);

                // Search with both methods (only if loaded)
                showStatus('Searching...', 'info');

                let directResults = null;
                let directTime = null;
                let fastplaidResult = null;
                let fastplaidTime = null;

                // Direct MaxSim: Exhaustive search over all papers (if loaded)
                if (loadingState.directMaxSim.loaded) {
                    const directStart = performance.now();
                    directResults = searchDirectMaxSim(queryEmb, numQueryTokens, embeddingDim, 10);
                    directTime = performance.now() - directStart;
                    console.log('‚úÖ Direct MaxSim:', directResults.length, 'results in', directTime.toFixed(1), 'ms (all', papers.length, 'papers)');
                } else {
                    console.log('‚è≥ Direct MaxSim: Not loaded yet');
                }

                // FastPlaid: Using WASM's 4-bit quantized index with IVF clustering (if loaded)
                if (loadingState.fastPlaid.loaded) {
                    const fastplaidStart = performance.now();
                    fastplaidResult = searchFastPlaid(queryEmb, numQueryTokens, embeddingDim, 10);
                    fastplaidTime = performance.now() - fastplaidStart;
                    console.log('‚úÖ FastPlaid:', fastplaidResult.results.length, 'results in', fastplaidTime.toFixed(1), 'ms');
                    console.log(`   üéØ IVF: ${fastplaidResult.numClustersProbed} clusters ‚Üí ${fastplaidResult.candidatesSearched} candidates (${(fastplaidResult.candidatesSearched / papers.length * 100).toFixed(1)}% of papers)`);

                    if (directTime !== null) {
                        const speedup = (directTime / fastplaidTime).toFixed(1);
                        console.log(`   ‚ö° Speedup: ${speedup}x faster than Direct MaxSim`);
                    }
                } else {
                    console.log('‚è≥ FastPlaid: Not loaded yet');
                }

                // Display results (partial or full)
                displayResults(
                    directResults ? { results: directResults, searchTime: directTime } : null,
                    fastplaidResult ? {
                        results: fastplaidResult.results,
                        searchTime: fastplaidTime,
                        candidatesSearched: fastplaidResult.candidatesSearched,
                        numClustersProbed: fastplaidResult.numClustersProbed
                    } : null
                );

                // Show comparison panel
                document.getElementById('comparisonPanel').style.display = 'grid';

                // Show status message
                if (directResults && fastplaidResult) {
                    const speedupCalc = (directTime / fastplaidTime).toFixed(1);
                    const directSizeMB = 49.5;
                    const fastplaidSizeMB = 6.2;
                    const compression = (directSizeMB / fastplaidSizeMB).toFixed(1);
                    const searchPercent = (fastplaidResult.candidatesSearched / papers.length * 100).toFixed(0);
                    showStatus(
                        `‚úÖ FastPlaid: ${compression}x smaller, ${speedupCalc}x faster! ` +
                        `(IVF: ${fastplaidResult.numClustersProbed} clusters ‚Üí ${searchPercent}% of papers searched)`,
                        'success'
                    );
                } else if (directResults) {
                    showStatus(`‚úÖ Direct MaxSim results shown (FastPlaid still loading)`, 'info');
                } else if (fastplaidResult) {
                    showStatus(`‚úÖ FastPlaid results shown (Direct MaxSim still loading)`, 'info');
                }

            } catch (error) {
                console.error('Search error:', error);
                showStatus(`‚ùå Search error: ${error.message}`, 'error');
            } finally {
                // Re-enable search button if at least one index is ready
                if (loadingState.colbert.loaded && (loadingState.directMaxSim.loaded || loadingState.fastPlaid.loaded)) {
                    document.getElementById('searchBtn').disabled = false;
                }
            }
        }

        function displayResults(directResults, fastplaidResults) {
            // Update IVF statistics (if FastPlaid results available)
            if (fastplaidResults) {
                document.getElementById('clustersProbed').textContent = fastplaidResults.numClustersProbed || '~6';
                document.getElementById('candidatesCount').textContent = fastplaidResults.candidatesSearched || '~300';
            }

            // Update Direct MaxSim panel
            const directTimeEl = document.getElementById('directTime');
            const directDiv = document.getElementById('directResults');

            if (directResults) {
                // Show results
                directTimeEl.textContent = `${directResults.searchTime.toFixed(1)} ms`;
                directTimeEl.className = 'method-time ' + (fastplaidResults && directResults.searchTime > fastplaidResults.searchTime ? 'slow' : 'fast');

                directDiv.innerHTML = directResults.results.map((result, idx) => `
                    <div class="result-item">
                        <div class="result-title">${idx + 1}. ${result.paper.title}</div>
                        <div class="result-score">Score: ${result.score.toFixed(4)} | ID: ${result.paper.id}</div>
                        <div class="result-abstract">${result.paper.abstract.substring(0, 150)}...</div>
                    </div>
                `).join('');
            } else {
                // Show loading indicator
                directTimeEl.textContent = '‚è≥ Loading...';
                directTimeEl.className = 'method-time';
                directDiv.innerHTML = '<div class="status-message status-info">‚è≥ Direct MaxSim index is still loading. Results will appear when ready.</div>';
            }

            // Update FastPlaid panel
            const fastplaidTimeEl = document.getElementById('fastplaidTime');
            const fastplaidDiv = document.getElementById('fastplaidResults');

            if (fastplaidResults) {
                // Show results
                fastplaidTimeEl.textContent = `${fastplaidResults.searchTime.toFixed(1)} ms`;
                fastplaidTimeEl.className = 'method-time ' + (directResults && fastplaidResults.searchTime < directResults.searchTime ? 'fast' : 'slow');

                fastplaidDiv.innerHTML = fastplaidResults.results.map((result, idx) => `
                    <div class="result-item">
                        <div class="result-title">${idx + 1}. ${result.paper.title}</div>
                        <div class="result-score">Score: ${result.score.toFixed(4)} | ID: ${result.paper.id}</div>
                        <div class="result-abstract">${result.paper.abstract.substring(0, 150)}...</div>
                    </div>
                `).join('');
            } else {
                // Show loading indicator
                fastplaidTimeEl.textContent = '‚è≥ Loading...';
                fastplaidTimeEl.className = 'method-time';
                fastplaidDiv.innerHTML = '<div class="status-message status-info">‚è≥ FastPlaid index is still loading. Results will appear when ready.</div>';
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
        }
    </script>
</body>
</html>
