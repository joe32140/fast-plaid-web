<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastPlaid Demo - mxbai-edge-colbert-v0-17m with 4-bit Quantization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 36px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 18px;
            opacity: 0.9;
        }

        .github-corner {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 1000;
        }

        .github-corner svg {
            fill: white;
            color: #667eea;
            width: 80px;
            height: 80px;
        }

        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
        }

        @keyframes octocat-wave {
            0%, 100% { transform: rotate(0); }
            20%, 60% { transform: rotate(-25deg); }
            40%, 80% { transform: rotate(10deg); }
        }

        .stats-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card.green {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .stat-card.orange {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .search-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .search-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #queryInput {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        #queryInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .comparison-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .method-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .method-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .method-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .method-time {
            font-size: 18px;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 20px;
            background: #f0f0f0;
        }

        .method-time.fast {
            background: #d4edda;
            color: #155724;
        }

        .method-time.slow {
            background: #f8d7da;
            color: #721c24;
        }

        .method-description {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .result-item {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
        }

        .result-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .result-score {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .result-abstract {
            font-size: 14px;
            color: #777;
            line-height: 1.4;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 1200px) {
            .comparison-panel {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .search-controls {
                flex-direction: column;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- GitHub Corner -->
    <a href="https://github.com/joe32140/fast-plaid-web" class="github-corner" aria-label="View source on GitHub" target="_blank">
        <svg viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>

    <div class="container">
        <div class="header">
            <h1>📊 ColBERT MaxSim: Comparing Optimization Strategies</h1>
            <p>Search 1000 arXiv Papers with <a href="https://huggingface.co/mixedbread-ai/mxbai-edge-colbert-v0-17m" target="_blank" style="color: white; font-weight: bold; text-decoration: underline;">mixedbread-ai/mxbai-edge-colbert-v0-17m</a></p>
            <p style="font-size: 16px; margin-top: 5px; opacity: 0.8;">Baseline JavaScript vs <a href="https://github.com/joe32140/maxsim-web" target="_blank" style="color: white; font-weight: bold; text-decoration: underline;">maxsim-web</a> (WASM+SIMD) vs <a href="https://github.com/joe32140/fast-plaid" target="_blank" style="color: white; font-weight: bold; text-decoration: underline;">FastPlaid-Web</a> (4-bit + IVF)</p>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <h2 style="margin-bottom: 15px;">📊 Index Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="numPapers">-</div>
                    <div class="stat-label">Research Papers</div>
                </div>
                <div class="stat-card orange">
                    <div class="stat-value" id="directSize">-</div>
                    <div class="stat-label">JS Baseline (float32)</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    <div class="stat-value" id="wasmSize">-</div>
                    <div class="stat-label">maxsim-web (float32)</div>
                </div>
                <div class="stat-card green">
                    <div class="stat-value" id="fastplaidSize">-</div>
                    <div class="stat-label">FastPlaid-Web (4-bit)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="compression">-</div>
                    <div class="stat-label">Size Reduction</div>
                </div>
            </div>
            <div id="statusMessage" style="margin-top: 20px;"></div>
        </div>

        <!-- Search Panel -->
        <div class="search-panel">
            <h2 style="margin-bottom: 15px;">🔍 Search Research Papers</h2>
            <div class="search-controls">
                <input type="text" id="queryInput" value="Simple Projection Variants Improve ColBERT Performance" />
                <button class="btn btn-primary" id="searchBtn">Search All</button>
            </div>
        </div>

        <!-- Comparison Panel -->
        <div class="comparison-panel" id="comparisonPanel" style="display: none;">
            <!-- JS Baseline Results -->
            <div class="method-panel">
                <div class="method-header">
                    <div class="method-title">🐢 JS Baseline</div>
                    <div class="method-time" id="directTime">- ms</div>
                </div>
                <div class="method-description">
                    <strong>Pure JavaScript</strong><br>
                    Float32 precision, exhaustive search (baseline for comparison)
                </div>
                <div id="directResults"></div>
            </div>

            <!-- maxsim-web Results -->
            <div class="method-panel">
                <div class="method-header">
                    <div class="method-title">🚀 maxsim-web</div>
                    <div class="method-time" id="wasmTime">- ms</div>
                </div>
                <div class="method-description">
                    <strong>WebAssembly + SIMD</strong> (<a href="https://github.com/joe32140/maxsim-web" target="_blank" style="color: #667eea; text-decoration: underline;">maxsim-web</a>)<br>
                    Full precision, 3-5x faster via WASM+SIMD, searches all papers
                </div>
                <div id="wasmResults"></div>
            </div>

            <!-- FastPlaid-Web Results -->
            <div class="method-panel">
                <div class="method-header">
                    <div class="method-title">⚡ FastPlaid-Web</div>
                    <div class="method-time" id="fastplaidTime">- ms</div>
                </div>
                <div class="method-description">
                    <strong>4-bit Quantization + IVF Indexing</strong> (<a href="https://github.com/joe32140/fast-plaid" target="_blank" style="color: #667eea; text-decoration: underline;">FastPlaid-Web</a>)<br>
                    8x smaller, <span id="clustersProbed">~6</span> clusters → <span id="candidatesCount">~300</span> candidates (speed + memory trade-off)
                </div>
                <div id="fastplaidResults"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { FastPlaidQuantized } from './pkg/fast_plaid_rust.js';
        import { PrecomputedIndexLoader } from './precomputed-index-loader.js';
        import { MaxSimWasm } from './maxsim-wasm.js';

        let indexLoader = null;
        let directEmbeddings = null;
        let fastPlaidWasm = null;  // FastPlaid-Web WASM instance
        let wasmMaxSim = null;  // maxsim-web WASM instance
        let papers = null;
        let colbertModel = null;

        // Expose to window for console access (to save index)
        window.fastPlaidWasm = null;
        window.saveFastPlaidIndex = () => {
            if (!window.fastPlaidWasm) {
                console.error('❌ FastPlaid not loaded yet!');
                return;
            }
            const indexBytes = window.fastPlaidWasm.save_index();
            const blob = new Blob([indexBytes], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'index.fastplaid';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('✅ Downloaded index.fastplaid! Move to demo/data/');
        };

        // Loading state management for all three methods
        const loadingState = {
            directMaxSim: { loaded: false, loading: false, error: null },
            wasmMaxSim: { loaded: false, loading: false, error: null },
            fastPlaid: { loaded: false, loading: false, error: null },
            colbert: { loaded: false, loading: false, error: null }
        };

        // Update UI to show loading state
        function updateLoadingUI(customMessage = null) {
            const directSize = document.getElementById('directSize');
            const wasmSize = document.getElementById('wasmSize');
            const fastplaidSize = document.getElementById('fastplaidSize');

            // JS Baseline size box
            if (loadingState.directMaxSim.loading) {
                directSize.innerHTML = '<span style="font-size:20px;">⏳</span> Loading...';
            } else if (loadingState.directMaxSim.error) {
                directSize.innerHTML = '<span style="font-size:20px;">❌</span> Error';
            } else if (loadingState.directMaxSim.loaded) {
                directSize.textContent = '49.5 MB';
            } else {
                directSize.textContent = '-';
            }

            // maxsim-web size box (same data as JS Baseline)
            if (loadingState.wasmMaxSim.loading) {
                wasmSize.innerHTML = '<span style="font-size:20px;">⏳</span> Loading...';
            } else if (loadingState.wasmMaxSim.error) {
                wasmSize.innerHTML = '<span style="font-size:20px;">❌</span> Error';
            } else if (loadingState.wasmMaxSim.loaded) {
                wasmSize.textContent = '49.5 MB';
            } else {
                wasmSize.textContent = '-';
            }

            // FastPlaid-Web size box (with custom message support)
            if (customMessage) {
                fastplaidSize.innerHTML = `<span style="font-size:20px;">🔧</span> ${customMessage}`;
            } else if (loadingState.fastPlaid.loading) {
                fastplaidSize.innerHTML = '<span style="font-size:20px;">⏳</span> Loading...';
            } else if (loadingState.fastPlaid.error) {
                fastplaidSize.innerHTML = '<span style="font-size:20px;">❌</span> Error';
            } else if (loadingState.fastPlaid.loaded) {
                fastplaidSize.textContent = '6.2 MB';
            } else {
                fastplaidSize.textContent = '-';
            }

            // Update compression ratio if both loaded
            if (loadingState.directMaxSim.loaded && loadingState.fastPlaid.loaded) {
                document.getElementById('compression').textContent = '8.0x';
            } else {
                document.getElementById('compression').textContent = '-';
            }
        }

        // Helper function to retry WASM operations
        async function retryAsync(fn, maxRetries = 3, delayMs = 500) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    console.warn(`Attempt ${attempt}/${maxRetries} failed:`, error.message);

                    if (attempt === maxRetries) {
                        throw error;
                    }

                    // Exponential backoff
                    const delay = delayMs * Math.pow(2, attempt - 1);
                    console.log(`Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));

                    // Force garbage collection if possible
                    if (window.gc) {
                        window.gc();
                    }
                }
            }
        }

        // Load maxsim-web
        async function loadWasmMaxSim() {
            loadingState.wasmMaxSim.loading = true;
            updateLoadingUI();

            try {
                console.log('🚀 Loading maxsim-web (with preloading support)...');
                showStatus('Loading maxsim-web...', 'info');

                // Create and initialize WASM instance with wrapper
                wasmMaxSim = new MaxSimWasm();
                await wasmMaxSim.init();

                loadingState.wasmMaxSim.loaded = true;
                loadingState.wasmMaxSim.loading = false;
                updateLoadingUI();

                console.log('✅ WASM MaxSim loaded with preloading support!');
                console.log('   Info:', wasmMaxSim.getInfo());

                // Check if SIMD is actually supported
                const simdSupported = await WebAssembly.validate(new Uint8Array([
                    0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3,
                    2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11
                ]));
                console.log('   🔍 Browser SIMD support:', simdSupported ? '✅ YES' : '❌ NO');

                if (!simdSupported) {
                    console.warn('⚠️ WASM SIMD NOT SUPPORTED - WASM will be slow!');
                    console.warn('   Use Chrome 91+, Firefox 89+, or Safari 16.4+');
                }

                updateOverallStatus();
            } catch (error) {
                console.error('❌ Error loading WASM MaxSim:', error);
                loadingState.wasmMaxSim.error = error.message;
                loadingState.wasmMaxSim.loading = false;
                updateLoadingUI();
                updateOverallStatus();
            }
        }

        // Load Direct MaxSim embeddings (async, independent)
        async function loadDirectMaxSimIndex() {
            loadingState.directMaxSim.loading = true;
            updateLoadingUI();

            try {
                console.log('📥 Loading Direct MaxSim embeddings...');
                showStatus('Loading Direct MaxSim embeddings...', 'info');

                const directData = await indexLoader.loadDirectMaxSimEmbeddings();
                directEmbeddings = directData.embeddings;

                console.log('✅ Direct MaxSim embeddings loaded (flat Float32Array format)');
                console.log('   Ready for both JS MaxSim and WASM Flat API');

                // Wait for WASM MaxSim to be ready before preloading
                console.log('⏳ Waiting for WASM MaxSim to initialize before preloading...');
                while (!loadingState.wasmMaxSim.loaded && !loadingState.wasmMaxSim.error) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Preload documents into WASM MaxSim if it's ready
                if (wasmMaxSim && loadingState.wasmMaxSim.loaded) {
                    console.log('🔄 Preloading documents into WASM MaxSim...');
                    try {
                        const embeddingDim = 48; // Known from our data

                        // Prepare flat embeddings data and doc_tokens array
                        const docTokens = new Uint32Array(directEmbeddings.length);
                        let totalTokens = 0;

                        for (let i = 0; i < directEmbeddings.length; i++) {
                            docTokens[i] = directEmbeddings[i].numTokens;
                            totalTokens += directEmbeddings[i].numTokens;
                        }

                        // Concatenate all embeddings into one flat array
                        const allEmbeddings = new Float32Array(totalTokens * embeddingDim);
                        let offset = 0;
                        for (let i = 0; i < directEmbeddings.length; i++) {
                            const docEmb = directEmbeddings[i].embedding;
                            allEmbeddings.set(docEmb, offset);
                            offset += docEmb.length;
                        }

                        wasmMaxSim.loadDocuments(allEmbeddings, docTokens, embeddingDim);
                        console.log(`✅ Preloaded ${directEmbeddings.length} documents into WASM memory!`);
                        console.log(`   Total tokens: ${totalTokens}, Data size: ${(allEmbeddings.length * 4 / 1024).toFixed(1)} KB`);
                        console.log('   Future searches will have ZERO conversion overhead!');
                    } catch (error) {
                        console.warn('⚠️ Failed to preload documents:', error);
                        console.warn('   Will fall back to per-search conversion');
                    }
                } else {
                    console.warn('⚠️ WASM MaxSim not available - skipping preload');
                }

                loadingState.directMaxSim.loaded = true;
                loadingState.directMaxSim.loading = false;
                updateLoadingUI();
                updateOverallStatus();
            } catch (error) {
                console.error('❌ Error loading Direct MaxSim:', error);
                loadingState.directMaxSim.error = error.message;
                loadingState.directMaxSim.loading = false;
                updateLoadingUI();
                updateOverallStatus();
            }
        }

        // Load FastPlaid index (async, independent)
        async function loadFastPlaidIndex() {
            loadingState.fastPlaid.loading = true;
            updateLoadingUI();

            try {
                console.log('📥 Loading FastPlaid index...');

                // Initialize WASM if not already done
                await retryAsync(async () => {
                    await init();
                    console.log('✅ WASM initialized');
                }, 3, 500);

                // Try to load precomputed .fastplaid index first (FAST!)
                try {
                    console.log('🔍 Checking for precomputed index.fastplaid...');
                    const indexResponse = await fetch('./data/index.fastplaid');

                    if (indexResponse.ok) {
                        console.log('📦 Loading precomputed .fastplaid index from disk...');
                        showStatus('💾 Loading FastPlaid from precomputed index...', 'info');
                        updateLoadingUI('Loading...');

                        const startTime = performance.now();
                        const indexBytes = await indexResponse.arrayBuffer();

                        fastPlaidWasm = new FastPlaidQuantized();
                        window.fastPlaidWasm = fastPlaidWasm;  // Expose to console
                        fastPlaidWasm.load_index(new Uint8Array(indexBytes));

                        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
                        console.log(`✅ FastPlaid loaded from disk in ${loadTime}s!`);

                        loadingState.fastPlaid.loaded = true;
                        loadingState.fastPlaid.loading = false;
                        updateLoadingUI();
                        updateOverallStatus();
                        return; // Success - exit early!
                    }
                } catch (e) {
                    console.log('⚠️ Precomputed index not found, will build from embeddings');
                }

                // Fallback: Build from embeddings (SLOW but works)
                console.log('🔨 Building FastPlaid index from embeddings...');

                // Wait for Direct MaxSim to load first (we need the embeddings)
                console.log('⏳ Waiting for Direct MaxSim embeddings to load...');
                showStatus('⏳ Waiting for embeddings to load...', 'info');

                while (!loadingState.directMaxSim.loaded && !loadingState.directMaxSim.error) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (loadingState.directMaxSim.error) {
                    throw new Error('Cannot build FastPlaid: Direct MaxSim embeddings failed to load');
                }

                console.log('✅ Embeddings ready, now quantizing to 4-bit + building IVF index...');
                showStatus('🔧 Quantizing to 4-bit + building IVF clusters in WASM (10-15s)...', 'info');
                updateLoadingUI('Building...');

                // Create WASM instance and build quantized index
                const startTime = performance.now();
                await retryAsync(async () => {
                    fastPlaidWasm = new FastPlaidQuantized();
                    window.fastPlaidWasm = fastPlaidWasm;  // Expose to console

                    // Prepare embeddings and doc_info for WASM
                    const flatEmbeddings = new Float32Array(
                        directEmbeddings.flatMap(doc => Array.from(doc.embedding))
                    );
                    const docInfo = new BigInt64Array(
                        directEmbeddings.flatMap((doc, idx) => [BigInt(idx), BigInt(doc.numTokens)])
                    );

                    // Let WASM quantize (256 centroids) and build IVF index
                    await fastPlaidWasm.load_documents_quantized(flatEmbeddings, docInfo, 256);
                }, 3, 1000);

                const buildTime = ((performance.now() - startTime) / 1000).toFixed(1);
                console.log(`✅ FastPlaid index built in ${buildTime}s (4-bit quantization + IVF clustering)`);

                // Optionally save the built index (disabled to avoid repeated downloads)
                // To save manually: Open browser console and run:
                //   saveIndexToFile()
                window.saveIndexToFile = () => {
                    try {
                        console.log('💾 Saving built index to fastplaid_index.bin...');
                        const indexBytes = fastPlaidWasm.save_index();
                        const blob = new Blob([indexBytes], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'fastplaid_index.bin';
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log('✅ Index saved! Move it to demo/data/ to use as precomputed index.');
                    } catch (err) {
                        console.error('⚠️  Failed to save index:', err);
                    }
                };
                console.log('💡 To save index: run saveIndexToFile() in console');

                loadingState.fastPlaid.loaded = true;
                loadingState.fastPlaid.loading = false;
                updateLoadingUI();

                updateOverallStatus();
            } catch (error) {
                console.error('❌ Error loading FastPlaid:', error);
                loadingState.fastPlaid.error = error.message;
                loadingState.fastPlaid.loading = false;
                updateLoadingUI();

                let helpText = '';
                if (error.message.includes('Table.grow') || error.message.includes('Memory')) {
                    helpText = '<br><br>💡 This is a WASM memory issue. Try:<br>' +
                               '• Refreshing the page (Ctrl+Shift+R)<br>' +
                               '• Closing other tabs to free memory<br>' +
                               '• Using a browser with more WASM support (Chrome/Edge)';
                } else if (error.message.includes('fetch') || error.message.includes('network')) {
                    helpText = '<br><br>💡 Network issue. Make sure embeddings.bin loaded successfully.';
                }
                showStatus(`❌ FastPlaid Error: ${error.message}${helpText}`, 'error');
                updateOverallStatus();
            }
        }

        // Load ColBERT model for query encoding
        async function loadColBertModel() {
            loadingState.colbert.loading = true;

            try {
                console.log('🤖 Loading ColBERT model...');
                showStatus('Loading ColBERT model for query encoding...', 'info');

                // Load mxbai-integration.js if not already loaded
                if (!window.MxbaiEdgeColbertIntegration) {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = './mxbai-integration.js';
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }

                colbertModel = new window.MxbaiEdgeColbertIntegration();
                await colbertModel.initializeModel();

                loadingState.colbert.loaded = true;
                loadingState.colbert.loading = false;

                console.log('✅ ColBERT model loaded!');
                updateOverallStatus();
            } catch (error) {
                console.error('❌ Error loading ColBERT:', error);
                loadingState.colbert.error = error.message;
                loadingState.colbert.loading = false;
                showStatus(`❌ ColBERT Error: ${error.message}`, 'error');
                updateOverallStatus();
            }
        }

        // Update overall status message
        function updateOverallStatus() {
            const direct = loadingState.directMaxSim;
            const wasm = loadingState.wasmMaxSim;
            const fastplaid = loadingState.fastPlaid;
            const colbert = loadingState.colbert;

            // Count loaded, loading, errored
            const loaded = [direct.loaded, wasm.loaded, fastplaid.loaded, colbert.loaded].filter(Boolean).length;
            const loading = [direct.loading, wasm.loading, fastplaid.loading, colbert.loading].filter(Boolean).length;
            const errors = [direct.error, wasm.error, fastplaid.error, colbert.error].filter(Boolean).length;

            if (loaded === 4) {
                showStatus(`✅ All systems ready! Try: "Simple Projection Variants Improve ColBERT Performance"`, 'success');
                document.getElementById('searchBtn').disabled = false;
            } else if (errors > 0 && loading === 0) {
                let msg = '⚠️ Partial system ready. ';
                if (direct.loaded) msg += 'JS MaxSim: ✅ ';
                if (wasm.loaded) msg += 'WASM MaxSim: ✅ ';
                if (fastplaid.loaded) msg += 'FastPlaid: ✅ ';
                if (colbert.loaded) msg += 'ColBERT: ✅';
                showStatus(msg, 'info');

                // Enable search if at least one index and colbert are ready
                if (colbert.loaded && (direct.loaded || wasm.loaded || fastplaid.loaded)) {
                    document.getElementById('searchBtn').disabled = false;
                }
            } else if (loading > 0) {
                let msg = '⏳ Loading... ';
                if (direct.loading) msg += 'JS MaxSim... ';
                if (wasm.loading) msg += 'WASM MaxSim... ';
                if (fastplaid.loading) msg += 'FastPlaid... ';
                if (colbert.loading) msg += 'ColBERT... ';
                showStatus(msg, 'info');
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            showStatus('Initializing...', 'info');
            updateLoadingUI();

            try {
                indexLoader = new PrecomputedIndexLoader('./data');

                // Load papers metadata first (required for display)
                console.log('📂 Loading papers metadata...');
                papers = await indexLoader.loadPapersMetadata();
                document.getElementById('numPapers').textContent = papers.length;
                console.log(`✅ Loaded ${papers.length} papers metadata`);

                // Start loading all indexes in parallel (truly independent)
                Promise.all([
                    loadDirectMaxSimIndex(),
                    loadWasmMaxSim(),
                    loadFastPlaidIndex(),
                    loadColBertModel()
                ]).catch(err => {
                    console.error('Unexpected error in parallel loading:', err);
                });

                // Attach event listeners
                document.getElementById('searchBtn').addEventListener('click', performSearch);
                document.getElementById('queryInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !document.getElementById('searchBtn').disabled) {
                        performSearch();
                    }
                });

            } catch (error) {
                console.error('Critical initialization error:', error);
                showStatus(`❌ Critical Error: ${error.message}`, 'error');
            }
        });

        // MaxSim scoring function
        function maxSim(queryTokens, docTokens, numQueryTokens, numDocTokens, embeddingDim) {
            let totalScore = 0;
            for (let q = 0; q < numQueryTokens; q++) {
                let maxScore = -Infinity;
                for (let d = 0; d < numDocTokens; d++) {
                    let dotProduct = 0;
                    for (let i = 0; i < embeddingDim; i++) {
                        dotProduct += queryTokens[q * embeddingDim + i] * docTokens[d * embeddingDim + i];
                    }
                    maxScore = Math.max(maxScore, dotProduct);
                }
                totalScore += maxScore;
            }
            return totalScore;
        }

        // Direct MaxSim search (JS implementation)
        function searchDirectMaxSim(queryEmb, numQueryTokens, embeddingDim, topK) {
            const scores = [];

            for (let docId = 0; docId < directEmbeddings.length; docId++) {
                const docEmb = directEmbeddings[docId];
                const score = maxSim(queryEmb, docEmb.embedding, numQueryTokens, docEmb.numTokens, embeddingDim);
                scores.push({ docId, score });
            }

            // Sort by score and return top-K
            scores.sort((a, b) => b.score - a.score);
            return scores.slice(0, topK).map(s => ({
                paper: papers[s.docId],
                score: s.score
            }));
        }

        // WASM MaxSim search with preloading (ZERO conversion overhead!)
        function searchWasmMaxSim(queryEmb, numQueryTokens, embeddingDim, topK) {
            const t0 = performance.now();

            console.log('🔍 WASM MaxSim Search (Preloaded):');
            console.log('  Query tokens:', numQueryTokens, 'Embedding dim:', embeddingDim);
            console.log('  Preloaded docs:', typeof wasmMaxSim.numDocumentsLoaded === 'function' ? wasmMaxSim.numDocumentsLoaded() : 'N/A (old WASM)');

            // Check if documents are preloaded (with safety check for method availability)
            const usePreloaded = (typeof wasmMaxSim.numDocumentsLoaded === 'function') &&
                                  wasmMaxSim.numDocumentsLoaded() > 0;

            let batchScores;
            if (usePreloaded) {
                // ULTRA-FAST PATH: Use preloaded documents (ZERO conversion overhead!)
                console.log('  ⚡ Using preloaded documents - NO conversion overhead!');

                // Convert flat query to 2D format for searchPreloaded()
                const query2D = [];
                for (let i = 0; i < numQueryTokens; i++) {
                    const tokenStart = i * embeddingDim;
                    query2D.push(queryEmb.slice(tokenStart, tokenStart + embeddingDim));
                }

                const t1 = performance.now();
                batchScores = wasmMaxSim.searchPreloaded(query2D);
                const wasmTime = performance.now() - t1;

                console.log('  ✨ Search time (preloaded):', wasmTime.toFixed(1), 'ms');
                console.log('  Avg time per doc:', (wasmTime / batchScores.length).toFixed(3), 'ms');
                console.log('  Total time:', (performance.now() - t0).toFixed(1), 'ms');
            } else {
                // FALLBACK PATH: Documents not preloaded, use old method
                console.log('  ⚠️ Documents not preloaded - using fallback (with conversion overhead)');

                const t1 = performance.now();

                let totalDocTokens = 0;
                const docTokenCounts = new Uint32Array(directEmbeddings.length);
                for (let i = 0; i < directEmbeddings.length; i++) {
                    docTokenCounts[i] = directEmbeddings[i].numTokens;
                    totalDocTokens += directEmbeddings[i].numTokens;
                }

                const allDocsFlat = new Float32Array(totalDocTokens * embeddingDim);
                let offset = 0;
                for (let i = 0; i < directEmbeddings.length; i++) {
                    const docEmb = directEmbeddings[i].embedding;
                    allDocsFlat.set(docEmb, offset);
                    offset += docEmb.length;
                }

                const packTime = performance.now() - t1;
                console.log('  Data packing time:', packTime.toFixed(1), 'ms');

                const t2 = performance.now();
                batchScores = wasmMaxSim.wasmInstance.maxsim_batch(
                    queryEmb,
                    numQueryTokens,
                    allDocsFlat,
                    docTokenCounts,
                    embeddingDim
                );
                const wasmTime = performance.now() - t2;

                console.log('  WASM time:', wasmTime.toFixed(1), 'ms');
                console.log('  Total time (packing + WASM):', (performance.now() - t0).toFixed(1), 'ms');
            }

            // Convert batch scores to result format
            const scores = [];
            for (let docId = 0; docId < directEmbeddings.length; docId++) {
                scores.push({ docId, score: batchScores[docId] });
            }

            // Sort by score and return top-K
            scores.sort((a, b) => b.score - a.score);
            return scores.slice(0, topK).map(s => ({
                paper: papers[s.docId],
                score: s.score
            }));
        }

        // FastPlaid search using WASM (4-bit quantized + IVF)
        function searchFastPlaid(queryEmb, numQueryTokens, embeddingDim, topK) {
            // WASM expects query_shape: [batch_size, seq_len, embedding_dim]
            const queryShape = new Uint32Array([1, numQueryTokens, embeddingDim]);

            // Use WASM's native search with IVF clustering
            const wasmResultJson = fastPlaidWasm.search(queryEmb, queryShape, topK);

            // Parse JSON result
            const wasmResults = JSON.parse(wasmResultJson);
            const firstResult = wasmResults[0]; // Get first query result (batch_size=1)

            // Log IVF statistics
            console.log(`⚡ IVF: Probed ${firstResult.num_clusters_probed} clusters, searched ${firstResult.candidates_searched}/${papers.length} papers`);

            // Convert WASM result to our format
            return {
                results: firstResult.passage_ids.map((docId, idx) => ({
                    paper: papers[docId],
                    score: firstResult.scores[idx]
                })),
                candidatesSearched: firstResult.candidates_searched,
                numClustersProbed: firstResult.num_clusters_probed
            };
        }

        async function performSearch() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            // Check if ColBERT is ready
            if (!loadingState.colbert.loaded) {
                showStatus('⏳ ColBERT model is still loading, please wait...', 'info');
                return;
            }

            // Check if at least one index is ready
            if (!loadingState.directMaxSim.loaded && !loadingState.wasmMaxSim.loaded && !loadingState.fastPlaid.loaded) {
                showStatus('⏳ All indexes are still loading, please wait...', 'info');
                return;
            }

            showStatus('Encoding query...', 'info');
            document.getElementById('searchBtn').disabled = true;

            try {
                // Encode query using ColBERT
                const queryEncoded = await colbertModel.encodeText(query, true);
                const queryEmb = queryEncoded.embeddings;
                const numQueryTokens = queryEncoded.numTokens;
                const embeddingDim = queryEncoded.tokenDim;

                console.log('🔍 Query:', query);
                console.log('   Tokens:', numQueryTokens, 'Dim:', embeddingDim);

                // Search with all three methods (only if loaded)
                showStatus('Searching...', 'info');

                let directResults = null;
                let directTime = null;
                let wasmResults = null;
                let wasmTime = null;
                let fastplaidResult = null;
                let fastplaidTime = null;

                // Direct MaxSim: Exhaustive search over all papers (if loaded)
                if (loadingState.directMaxSim.loaded) {
                    const directStart = performance.now();
                    directResults = searchDirectMaxSim(queryEmb, numQueryTokens, embeddingDim, 10);
                    directTime = performance.now() - directStart;
                    console.log('✅ JS MaxSim:', directResults.length, 'results in', directTime.toFixed(1), 'ms (all', papers.length, 'papers)');
                } else {
                    console.log('⏳ JS MaxSim: Not loaded yet');
                }

                // WASM MaxSim: Exhaustive search over all papers using WASM (if loaded)
                if (loadingState.wasmMaxSim.loaded && loadingState.directMaxSim.loaded) {
                    console.log('🔍 Pre-WASM check:');
                    console.log('  queryEmb type:', queryEmb.constructor.name);
                    console.log('  queryEmb length:', queryEmb.length);
                    console.log('  Expected length (tokens * dim):', numQueryTokens * embeddingDim);
                    console.log('  First 5 values:', Array.from(queryEmb.slice(0, 5)));

                    const wasmStart = performance.now();
                    wasmResults = searchWasmMaxSim(queryEmb, numQueryTokens, embeddingDim, 10);
                    wasmTime = performance.now() - wasmStart;
                    console.log('✅ WASM MaxSim:', wasmResults.length, 'results in', wasmTime.toFixed(1), 'ms (all', papers.length, 'papers)');
                    if (directTime !== null) {
                        const speedup = (directTime / wasmTime).toFixed(1);
                        console.log(`   ⚡ Speedup: ${speedup}x faster than JS MaxSim`);
                    }
                } else {
                    console.log('⏳ WASM MaxSim: Not loaded yet');
                }

                // FastPlaid: Using WASM's 4-bit quantized index with IVF clustering (if loaded)
                if (loadingState.fastPlaid.loaded) {
                    const fastplaidStart = performance.now();
                    fastplaidResult = searchFastPlaid(queryEmb, numQueryTokens, embeddingDim, 10);
                    fastplaidTime = performance.now() - fastplaidStart;
                    console.log('✅ FastPlaid:', fastplaidResult.results.length, 'results in', fastplaidTime.toFixed(1), 'ms');
                    console.log(`   🎯 IVF: ${fastplaidResult.numClustersProbed} clusters → ${fastplaidResult.candidatesSearched} candidates (${(fastplaidResult.candidatesSearched / papers.length * 100).toFixed(1)}% of papers)`);

                    if (directTime !== null) {
                        const speedup = (directTime / fastplaidTime).toFixed(1);
                        console.log(`   ⚡ Speedup: ${speedup}x faster than Direct MaxSim`);
                    }
                } else {
                    console.log('⏳ FastPlaid: Not loaded yet');
                }

                // Display results (partial or full)
                displayResults(
                    directResults ? { results: directResults, searchTime: directTime } : null,
                    wasmResults ? { results: wasmResults, searchTime: wasmTime } : null,
                    fastplaidResult ? {
                        results: fastplaidResult.results,
                        searchTime: fastplaidTime,
                        candidatesSearched: fastplaidResult.candidatesSearched,
                        numClustersProbed: fastplaidResult.numClustersProbed
                    } : null
                );

                // Show comparison panel
                document.getElementById('comparisonPanel').style.display = 'grid';

                // Show status message
                let statusMsg = '✅ Search complete! ';
                if (wasmTime && directTime) {
                    const wasmSpeedup = (directTime / wasmTime).toFixed(1);
                    statusMsg += `WASM ${wasmSpeedup}x faster than JS. `;
                }
                if (fastplaidTime && directTime) {
                    const fastplaidSpeedup = (directTime / fastplaidTime).toFixed(1);
                    statusMsg += `FastPlaid ${fastplaidSpeedup}x faster than JS. `;
                }
                if (fastplaidResult) {
                    const searchPercent = (fastplaidResult.candidatesSearched / papers.length * 100).toFixed(0);
                    statusMsg += `(FastPlaid searched ${searchPercent}% of papers via IVF)`;
                }
                showStatus(statusMsg, 'success');

            } catch (error) {
                console.error('Search error:', error);
                showStatus(`❌ Search error: ${error.message}`, 'error');
            } finally {
                // Re-enable search button if at least one index is ready
                if (loadingState.colbert.loaded && (loadingState.directMaxSim.loaded || loadingState.wasmMaxSim.loaded || loadingState.fastPlaid.loaded)) {
                    document.getElementById('searchBtn').disabled = false;
                }
            }
        }

        function displayResults(directResults, wasmResults, fastplaidResults) {
            // Update IVF statistics (if FastPlaid results available)
            if (fastplaidResults) {
                document.getElementById('clustersProbed').textContent = fastplaidResults.numClustersProbed || '~6';
                document.getElementById('candidatesCount').textContent = fastplaidResults.candidatesSearched || '~300';
            }

            // Determine fastest time for comparison
            const times = [
                directResults?.searchTime,
                wasmResults?.searchTime,
                fastplaidResults?.searchTime
            ].filter(t => t !== undefined && t !== null);
            const fastestTime = times.length > 0 ? Math.min(...times) : null;

            // Update JS MaxSim panel
            const directTimeEl = document.getElementById('directTime');
            const directDiv = document.getElementById('directResults');

            if (directResults) {
                directTimeEl.textContent = `${directResults.searchTime.toFixed(1)} ms`;
                directTimeEl.className = 'method-time ' + (fastestTime && directResults.searchTime > fastestTime * 1.1 ? 'slow' : 'fast');

                directDiv.innerHTML = directResults.results.map((result, idx) => `
                    <div class="result-item">
                        <div class="result-title">${idx + 1}. ${result.paper.title}</div>
                        <div class="result-score">Score: ${result.score.toFixed(4)} | ID: ${result.paper.id}</div>
                        <div class="result-abstract">${result.paper.abstract.substring(0, 150)}...</div>
                    </div>
                `).join('');
            } else {
                directTimeEl.textContent = '⏳ Loading...';
                directTimeEl.className = 'method-time';
                directDiv.innerHTML = '<div class="status-message status-info">⏳ JS MaxSim index is still loading. Results will appear when ready.</div>';
            }

            // Update WASM MaxSim panel
            const wasmTimeEl = document.getElementById('wasmTime');
            const wasmDiv = document.getElementById('wasmResults');

            if (wasmResults) {
                wasmTimeEl.textContent = `${wasmResults.searchTime.toFixed(1)} ms`;
                wasmTimeEl.className = 'method-time ' + (fastestTime && wasmResults.searchTime > fastestTime * 1.1 ? 'slow' : 'fast');

                wasmDiv.innerHTML = wasmResults.results.map((result, idx) => `
                    <div class="result-item">
                        <div class="result-title">${idx + 1}. ${result.paper.title}</div>
                        <div class="result-score">Score: ${result.score.toFixed(4)} | ID: ${result.paper.id}</div>
                        <div class="result-abstract">${result.paper.abstract.substring(0, 150)}...</div>
                    </div>
                `).join('');
            } else {
                wasmTimeEl.textContent = '⏳ Loading...';
                wasmTimeEl.className = 'method-time';
                wasmDiv.innerHTML = '<div class="status-message status-info">⏳ WASM MaxSim index is still loading. Results will appear when ready.</div>';
            }

            // Update FastPlaid panel
            const fastplaidTimeEl = document.getElementById('fastplaidTime');
            const fastplaidDiv = document.getElementById('fastplaidResults');

            if (fastplaidResults) {
                fastplaidTimeEl.textContent = `${fastplaidResults.searchTime.toFixed(1)} ms`;
                fastplaidTimeEl.className = 'method-time ' + (fastestTime && fastplaidResults.searchTime > fastestTime * 1.1 ? 'slow' : 'fast');

                fastplaidDiv.innerHTML = fastplaidResults.results.map((result, idx) => `
                    <div class="result-item">
                        <div class="result-title">${idx + 1}. ${result.paper.title}</div>
                        <div class="result-score">Score: ${result.score.toFixed(4)} | ID: ${result.paper.id}</div>
                        <div class="result-abstract">${result.paper.abstract.substring(0, 150)}...</div>
                    </div>
                `).join('');
            } else {
                fastplaidTimeEl.textContent = '⏳ Loading...';
                fastplaidTimeEl.className = 'method-time';
                fastplaidDiv.innerHTML = '<div class="status-message status-info">⏳ FastPlaid index is still loading. Results will appear when ready.</div>';
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
        }
    </script>
</body>
</html>
